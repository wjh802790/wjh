//#include<bits/stdc++.h>
//using namespace std;
//int main(){
//'&'与、'|'或、'^'异或、'~'非/取反 
// ^ 在一个序列中可以消除重复的数
// a^a=0 a^0=a a^a^b^c^c=b 
//	int a=1;
//	int b=0;
//	printf("%d\n",a&b);
//	printf("%d\n",a|b);
//	printf("%d\n",a^b);
//	printf("%d\n",~a);
//	printf("%d\n",~b);
//	printf("%d\n",a);
//	printf("%d\n",b);
//'>>'和'<<'运算符是将二进制位进行右移或者左移操作
//'>>>'运算符将用0填充高位；'>>'运算符 用符号位填充高位  
//没有'<<<'运算符
//#include<bits/stdc++.h>
//using namespace std;
//int main(){
//
//	int n = 0;
//	cin>>n;//n>0
	
	//用最简单的代码判断n是否为偶数 
//	if(n&(n-1)==0){
//		cout<<"n为偶数";
//	}
//}
	//if条件句判断n为奇数还是偶数 
//	if(n&1==1){
//		cout<<"n为奇数";
//	}else{
//		cout<<"n为偶数";
//	}

//交换两个整数变量的值 三次异或运算 
//	int a = 0;
//	int b = 0;
//	cin>>a>>b; 
//	printf("%d\n",a);
//	printf("%d\n",b);
//	a = a^b;
//	b = b^a;
//	a = a^b;
//	printf("%d\n",a);
//	printf("%d\n",b);
//	
	// 				 i 
	//获取二进制的某一位是0还是1
	//将这个二进制的某一位与1进行与运算，结果为1，该位为1，否则为0 
//	string str = ((100)&(1<<4)>>4)==0?"0":"1"; 
	//求第5位（从右往左数）二进制数是0还是1，可将1100100&10000得出，结果为0 
	//将1左移四位与运算后再右移四位再判断结果
	//	 
	
	//错误 
//	cout<<"100的第5位二进制是"<<str;
//	int i = 0;
//	cin>>i;
//	int sum = 0;
//	cin>>sum; 
	//sum的二进制序列的第i位是0还是1 
//	法1：将1左移到指定的第i位，然后再用&判断是否为1，最后右移第i位回去 
//	int str =(1<<(i-1)&sum)>>(i-1);
	//法2：先将数组右移指定第i位，然后再用&与1运算 
//	int str = sum >>(i-1)&1;
//	cout<<str; 
//	法3：整数转换成二进制字符串，再转成字符数组判断
	
	//找出唯一成对的数
	/* 
	唯一成对表明该数组中只有一个元素n出现两次，重新构造一个该数组但没有重复出现的数
	与这个数组的数相异或，因为这样只有n出现了三次，其余都是出现两次，消掉之后只剩下n
	int x = 0;
	for(int i =1;i<=n-1;i++){
		x = (x^i);
	} 
	for(int j=0;j<n;j++){
		x = x^arr[i];
	}
	 */
	 
	 
	//找出落单的那个数
	//思路：对数组连续异或，成对的都会消掉，落单的那个会保留 
	
	//二进制中1的个数
	//法1：
	//根据位运算 怎样判断某一位是不是1结合
//	int n;
//	cin>>n;
//	int count = 0;
//	for(int i=0;i<32;i++){
//		if((n&(1<<i))==(1<<i)){
//	//	比对每一位 
//			count++;
//		}
//	
//	} 
//		cout<<count;
	 
	//法2：
//	int n ;
//	cin>>n;
//	int count = 0;
//	for(int i=0;i<32;i++){
//		if(((n>>i)&1)==1){
//			count++;	
//		}
//		
//	}
//	cout<<count<<endl;
//	法3：根据n&(n-1)的效果是消去最低位上的1，能消几次，就有几个1 
//	while(n!=0){   //n==0是终止条件
// 	次数是未知的使用while循环 
//		n=n&(n-1);
//		count++;
//	}
//	cout<<count;
	
//	int m(int i){
//		int ou = i&0xaaaaaaaa;	//和1010 1010 1010 ....做与运算取出偶数位 
//		int ji = i&0x55555555;	//和0101 0101 0101 ....做与运算取出奇数位 
//		return (ou>>1)|(ji<<1)	//连起来 
//		//return (ou>>1) ^(ji<<1) //异或和或运算都可以 
//	}

	// 0-1间浮点实数的二进制表示
	//乘二取整数位，然后再把整数位变成0继续乘二 
	//整数转换成二进制序列
	//除二取余留商 
	
	//出现k次与出现1次
	//思路，k个相同的k进制进行不进位加法结果为0 
//}
